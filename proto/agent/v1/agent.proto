syntax = "proto3";

package infrapilot.agent.v1;

option go_package = "github.com/infrapilot/backend/internal/grpc/agentpb";

// AgentService handles all communication between backend and agents
service AgentService {
  // Register a new agent with the backend
  rpc Register(RegisterRequest) returns (RegisterResponse);

  // Heartbeat to maintain connection and sync state
  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse);

  // Bidirectional command stream for real-time operations
  rpc CommandStream(stream AgentMessage) returns (stream BackendMessage);

  // Stream logs from agent to backend
  rpc StreamLogs(LogStreamRequest) returns (stream LogEntry);

  // Push metrics from agent to backend
  rpc PushMetrics(MetricsRequest) returns (MetricsResponse);
}

// ============ Registration ============

message RegisterRequest {
  string enrollment_token = 1;
  string hostname = 2;
  string agent_version = 3;
  string os_info = 4;
}

message RegisterResponse {
  string agent_id = 1;
  bytes client_cert = 2;
  bytes client_key = 3;
  int32 heartbeat_interval_sec = 4;
}

// ============ Heartbeat ============

message HeartbeatRequest {
  string agent_id = 1;
  SystemMetrics metrics = 2;
  repeated ContainerState containers = 3;
}

message HeartbeatResponse {
  bool acknowledged = 1;
  repeated PendingCommand pending_commands = 2;
}

message PendingCommand {
  string request_id = 1;
  string command_type = 2;
  bytes payload = 3;
}

// ============ Command Stream ============

message BackendMessage {
  string request_id = 1;
  oneof command {
    DockerCommand docker = 10;
    NginxCommand nginx = 11;
    ExecCommand exec = 12;
    LogRequest logs = 13;
    DatabaseCheckCommand db_check = 14;
    NetworkCommand network = 15;
  }
}

message AgentMessage {
  string request_id = 1;
  oneof response {
    CommandResult result = 10;
    LogEntry log = 11;
    ExecOutput exec_output = 12;
    ErrorResponse error = 13;
    NetworkListResponse network_list = 14;
    NetworkAttachResult network_attach = 15;
    ContainerNetworksResponse container_networks = 16;
    NginxNetworkCheckResponse nginx_network_check = 17;
  }
}

// ============ Docker Commands ============

message DockerCommand {
  enum Action {
    ACTION_UNSPECIFIED = 0;
    ACTION_LIST = 1;
    ACTION_START = 2;
    ACTION_STOP = 3;
    ACTION_RESTART = 4;
    ACTION_INSPECT = 5;
    ACTION_LOGS = 6;
    ACTION_STATS = 7;
  }
  Action action = 1;
  string container_id = 2;
  map<string, string> options = 3;
}

// ============ Nginx Commands ============

message NginxCommand {
  enum Action {
    ACTION_UNSPECIFIED = 0;
    ACTION_GET_CONFIG = 1;
    ACTION_WRITE_CONFIG = 2;
    ACTION_TEST_CONFIG = 3;
    ACTION_RELOAD = 4;
    ACTION_GET_STATUS = 5;
  }
  Action action = 1;
  string config_content = 2;
  string config_path = 3;
}

// ============ Network Commands ============

message NetworkCommand {
  enum Action {
    ACTION_UNSPECIFIED = 0;
    ACTION_LIST_NETWORKS = 1;
    ACTION_GET_CONTAINER_NETWORKS = 2;
    ACTION_CHECK_NGINX_NETWORK = 3;
    ACTION_ATTACH_NGINX_NETWORK = 4;
    ACTION_DETACH_NGINX_NETWORK = 5;
  }
  Action action = 1;
  string network_id = 2;
  string container_id = 3;
}

message NetworkInfo {
  string id = 1;
  string name = 2;
  string driver = 3;
  string scope = 4;
  bool internal = 5;
  map<string, string> containers = 6;
}

message ContainerNetworkInfo {
  string network_id = 1;
  string network_name = 2;
  string ip_address = 3;
}

message NetworkListResponse {
  repeated NetworkInfo networks = 1;
}

message NetworkAttachResult {
  bool success = 1;
  string network_id = 2;
  string network_name = 3;
  string error_message = 4;
}

message ContainerNetworksResponse {
  repeated ContainerNetworkInfo networks = 1;
}

message NginxNetworkCheckResponse {
  bool connected = 1;
  string network_id = 2;
  string network_name = 3;
}

// ============ Exec Commands ============

message ExecCommand {
  string container_id = 1;
  repeated string command = 2;
  bool interactive = 3;
  bool tty = 4;
}

message ExecOutput {
  bytes stdout = 1;
  bytes stderr = 2;
  int32 exit_code = 3;
  bool is_final = 4;
}

// ============ Metrics ============

message SystemMetrics {
  double cpu_percent = 1;
  int64 memory_used_mb = 2;
  int64 memory_total_mb = 3;
  int64 disk_used_mb = 4;
  int64 disk_total_mb = 5;
  int64 uptime_seconds = 6;
}

message ContainerState {
  string container_id = 1;
  string name = 2;
  string image = 3;
  string status = 4;
  string stack_name = 5;
  double cpu_percent = 6;
  int64 memory_mb = 7;
  int64 memory_limit_mb = 8;
  int32 restart_count = 9;
}

message MetricsRequest {
  string agent_id = 1;
  SystemMetrics system = 2;
  repeated ContainerState containers = 3;
}

message MetricsResponse {
  bool acknowledged = 1;
}

// ============ Logs ============

message LogStreamRequest {
  enum Source {
    SOURCE_UNSPECIFIED = 0;
    SOURCE_NGINX_ACCESS = 1;
    SOURCE_NGINX_ERROR = 2;
    SOURCE_CONTAINER = 3;
  }
  Source source = 1;
  string container_id = 2;
  int64 since_timestamp = 3;
  bool follow = 4;
}

message LogEntry {
  int64 timestamp = 1;
  string source = 2;
  string level = 3;
  string message = 4;
  map<string, string> metadata = 5;
}

message LogRequest {
  LogStreamRequest.Source source = 1;
  string container_id = 2;
  int32 lines = 3;
  bool follow = 4;
}

// ============ Database Check ============

message DatabaseCheckCommand {
  string db_type = 1;
  string host = 2;
  int32 port = 3;
  string username = 4;
  string password = 5;
  string database = 6;
  bool ssl_enabled = 7;
}

// ============ Common ============

message CommandResult {
  bool success = 1;
  string message = 2;
  bytes data = 3;
}

message ErrorResponse {
  int32 code = 1;
  string message = 2;
}
